Spring Security Architecture

Dev Steps 
1. Add spring security starter dependencies in pom.xml
Effect -> all end points - protected (secured) - in accessible
 - Entire spring boot app 
  - under the authentication lock.

2. Defaults that spring security offers
- protects all endpoints (including swagger)
- supplies auto generated login n logout pages
  -  to support form login
- supports HTTP Basic authentication for REST clients
- suplies default user
 - name : user
 - password - randomly generated by spring sec.
- Offers CSRF protection
 - Creates HttpSession object , to store spring sec context (info)

3. Add spring sec user name n password in app properties file , to replace auto generated details.
    -user details are stored in mem.

4. Test end points using 
 - browser - form login
 - postman - basic auth.

4.2 Add Spring security configuration 
 - to disable CSRF protection
(Since CSRF protection is required in - stateful web app n not in stateless REST APIs - where entire state management is done on client side)


5. Authentication was done BUT no authorization!
6. To override defaults -
  - create spring configuration class
  - Annotations 
   - @Configuration
   - @EnableWebSecurity
   - @EnableMethodSecurity
7. Add a Bean (@Bean annotated method) 
 - to supply user details
  - using ready made imple class of UserDetailsService i/f
   - InMemoryUserDetailsManger - class 
    - added user details (name , pwd, Collection<GrantedAuthority> roles)
    - UserDetails - i/f - implemented by User class - spring sec class

8. Add a Bean (@Bean annotated method) 
 - to supply authorization rules, disable form login , disable CSRF ,enable basic auth , disable session ,
 - To return : SecurityFilterChain
 - Depcy (method arg) - HttpSecurity
 - disable CSRF protection (since RESTful web service - stateless)
 - authorized HTTP reqs 
  - permit all
   - swagger ("/v*/api-docs/**","/swagger-ui/**")
   - user siginin , user signup
   - public end points (eg - view products , check available flights...)
  - only authentication (eg - add product to cart)
  - authentication + authorization (eg - add product)
  - disable form login
  - enable basic auth (to be replaced later by JWT - more secure)
  - HTTP session  management - disable HTTP session


Flow 
REST clnt sends a request to REST server 
-> Intercepted by DelegatingFilterProxy
 - It is a Filter class .
 - Acts as bridge between servlet filters n spring beans
 - Delegates all work to a Spring-managed filter bean
  - To springSecurityFilterChain.
-> Spring sec filter chain  takes over 
 -> current filter - BasicAuthenticationFilter
  - Base 64  decoding of username:password
(Basic base64 enc username:password) - req header - "Authorization"
 -> BasicAuthenticationFilter delegates the authentication to AuthenticationManager (i/f) <--- imple by ProviderManager
 -> i.e Filter invokes - public Authentication authenticate(Authentication auth) throws AuthenticationException
 -> Authentication i/f 
  - auth token
  - imple class
  - UserNamePasswordAuthenticationToken
  - Filter creates instance of the UserNamePasswordAuthenticationToken(Object username ,Object password)
  - isAuthenticated : false (=> authentication is not yet done!)

-> AuthMgr iterates through the list of available AuthProviders
 - AuthMgr invokes supports() method
  - rets false - continues 
  - rets true 
   - AuthMgr calls - authenticate(Authentication obj) method of  selected Auth Provider

-> AuthenticationProvider -i/f 
 - imple by DaoAuthenticationProvider (default provider)

->2 Dependencies of AuthenticationProvider
   -1.  PasswordEncoder (i/f) <--- BCryptPasswordEncoder (imple class)
    - supplied by spring sec crypto package
    - to make it available as the dependency
     - configure it as a spring bean (@Bean)
     - in spring application class (main)
    - internally used by DaoAuthenticationProvider 
     - to encrypt (SHA-256 | 512) incoming password
    - 2. UserDetailsService i/f 
     - DaoAuthProvider uses it to fetch user details from either In mem | DB
     - Functional i/f
     - SAM - functional method
      -public UserDetails loadUserByUserName(String userName|email) throws            	UserNameNotFoundException
     
     - UserDetails - i/f 
      - represents actual user details fetched  from DB or memory
      - Methods
        public String getUserName()
	public String getPassword()
        public Collection<? extends GrantedAuthority> getAuthorities()

     -> DaoAuthProvider calls 
       loadUserByUserName(username) of UserDetailsService
       -> in case of success (=> username found)
           - rets UserDetails loaded from mem | db 
           - DaoAuthProvider verifies - pwd
            - tries to match incoming encrypted password  with the pwd stored in 			UserDetails object
            - in case of a match - authentication successfully done ! 
   -> DaoAuthProvider rets verified UserDetails to -> Auth Mgr
     -> It stores verified UserDetails in the Authentication object
        - sets isAuthenticated - true
    -> AuthMgr rets this fully authenticated , 
          Authentication object to BasicAuthFilter 
      - Authentication has - username , pwd : null ,Collection<GrantedAuthority> 

    -> BasicAuthFilter stores Authentication obj under Spring security Context

   -> Next important  filter AuthorizationFilter
     -> Extracts Granted Authorities from Spring security Context
           n performs role based authorization. 

    ->in case of complete success ->delegates the request to D.S (Front controller)
 
   -> In case of Authentication failure (AuthenticationException)
 -> Spring sec aborts the req processing -> sends SC 401 to the clnt
   ->  In case of Authorization failure (AuthorizationException)
 -> aborts the req processing -> sends SC 403 to the clnt


 
Next Dev steps
 Replace In mem user details service  by DB based auth.
 BUT will still use BasicAuth

1. Remove UserDetailsService bean form spring config file
2. Create custom imple class for - UserDetailsService
3. imple the method - loadUserByUserName
4. UserEntity implements - UserDetails
5. UserDao 
 - finder method - findByEmail
6. Test it !
 - test user signup (with enc pwd)
 - user sign in 
  - use postman client (Basic auth - username:pwd)

eg - {
  "firstName": "Rama",
  "lastName": "Kher",
  "email": "rama@gmail.com",
  "password": "abc#1234",
  "dob": "1990-05-14",
  "role": "ROLE_ADMIN"
}

{
  "firstName": "Mihir",
  "lastName": "Sen",
  "email": "mihir@gmail.com",
  "password": "xyz$1234",
  "dob": "1992-05-14",
  "role": "ROLE_CUSTOMER"
}


Objective - Replace Basic Auth mechanism by JWT
(Json Web Token)
Refer - jwt.io

Dev steps 
1. Copy from earlier basic auth sec project
2. Create new end point -
 user sign in
  - email , password
 - success - Auth Resp - message  + JWT
 - failed - SC 401 - returned by Spring sec.

2.1 In user sign in 
 - Simply call AuthenticationManager's authenticate method
  - Configure AuthenticationManager as a spring bean 
   - in spring sec config class
 - authenticate
    i/p - Authentication <- UserNamePasswordAuthToken (em,pass)
    o/p - throws exc | fully populated Auth object (em,pwd - null, granted authorities)
   -> simply add it to JWT 
    (JWT dependencies - jjwt)
   -> generate token.
   -> sends signed jwt to the clnt 

3. JWT token generation steps
3.1 Add JJWT dependencies in pom.xml
3.2 Add 2 properties in app properties file
      - JWT expiration time 
      - secret key (256 bit min - SHA256)
Refer - https://generate-random.org/encryption-key-generator

3.3 Create (copy) 
 - JWT Utils for the token generation
  - create token (to be used in sign in) 
  - validate token (to be used custom JWT filter)

3.4 Test User sign in endpoint (in swagger)
 - in case of successful auth 
 - JWT should be seen in resp .

4. In JS client 
 - store this token in local | session storage.
 - Any time clnt is making a request to the secured end point ,
  send this token (using React Interceptor) , in Authorization header 
-> to the server.


5. Create custom JWT filter 
 -  to intercept every incoming request
 - validate token
 - extract authentication object (JWT claims) 
  - in case of success - 
   - store valid auth object under Spring Sec ctx.

6. Add jwt filter before 
 UserNamePasswordAuthenticationFilter
 - in spring sec config class.

7. Test it !
 - postman 
(Use Auth - Bearer Token 
 paste - JWT token )
 Test secured end points for
  - authentication
  - role based authorization.

NOTE
- This JWT will expire by 5th June 

Sample admin credentials

{
  "firstName": "Anuja",
  "lastName": "Pathak",
  "email": "anu@gmail.com",
  "password": "Abc#12345",
  "dob": "1990-06-04",
  "role": "ROLE_ADMIN"
}

JWT - 
{
  "message": "successful login ....",
  "jwt": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhbnVAZ21haWwuY29tIiwiaWF0IjoxNzQ5MDMyODA1LCJleHAiOjE3NDkxMTkyMDUsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXX0.T1R_-tYraNB1YT4sFHcRD1mjHC_z25szx6vfG760E6w"
}

Sample Customer Credentials 
{
  "firstName": "Anish",
  "lastName": "Sethi",
  "email": "anish@gmail.com",
  "password": "Def#12345",
  "dob": "1992-06-04",
  "role": "ROLE_CUSTOMER"
}

JWT 
{
  "message": "successful login ....",
  "jwt": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhbmlzaEBnbWFpbC5jb20iLCJpYXQiOjE3NDkwMzkzNjQsImV4cCI6MTc0OTEyNTc2NCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9DVVNUT01FUiJdfQ.BhpmESFZXtmYi8fq3cuUi5W9y4ecrQtr4UXDNGIoExQ"
}

  
